// -*- c -*-
// montgomery operations

// Clang definitions
// #ifdef __clang__
// #define __global __attribute__((address_space(1)))
// int get_global_id(int index);
// #endif

// unrolling
//#define UNROLL __attribute__((opencl_unroll_hint))
//#define UNROLLN(n) __attribute__((opencl_unroll_hint(n)))

#define UNROLL
#define UNROLLN(n)

#define INT_T   int
#define UINT_T  unsigned int
#define UINTD_T unsigned long
#define UINTH_T unsigned short

#define STATIC
#define INLINE inline
#define GLOBAL __global
#define CONST  __constant
#define LOCAL  __local
#define PRIVATE __private

#define bit_sizeof(T) (sizeof(T)*8)
#define D_SIZE (sizeof(UINT_T)*8)

// GENERATED: K,S,N,Np,1
// generate:  mpz:format_mont(mpz:mont_w(Type,32)).


#include "digit.i"

// Generated by clmont:format_mont().
// -----------------------------------------------
#include "cios.i"
#define mont_K 1088
#define mont_S 34
CONST UINT_T mont_N[34] = {0xA7D5BFEB,0x09AFCC70,0xAA7AAC04,0x4A922B39,0x12026166,0xE2D2F727,0xA6B7A79F,0x847FEF21,0xCC08533B,0xF7ECBEFB,0xE1138146,0xBE94E560,0xD6CA5ADB,0x2FD38236,0x20084F6D,0x60663161,0x8155C999,0xCF71EAFA,0x5790E9CB,0x2EFD631C,0xCEC4921B,0x9946F63D,0x7A4F1B62,0x19085E86,0x7A881BA5,0x5C6B3C8C,0x782E32AF,0xD00AF4C2,0xD9BF852C,0x7E3D4768,0xFFD2F4DF,0xA10AEC7B,0x00000006,0x00000000};
CONST UINT_T mont_Np[34] = {0x69578F3D,0xBC1EBB24,0x847D9C4E,0x5F6730B1,0x1F7AD209,0x4910512F,0x5E6233E9,0xC2BCDC19,0xC4A019A2,0x786271B4,0xD9F90959,0xD12E22CC,0x469B740E,0x7C5112AE,0x1E14E970,0x2FCA4DC5,0x39D33F80,0xD707B247,0xC836F87C,0x3D624C4F,0x600C1F1F,0x2B3F141A,0xC14F9DF5,0xD32D8B3B,0x7261FE5A,0x43DC4F4C,0x3362EF4E,0x1339EF57,0x59C7B1DD,0x868A70DC,0x1F243EAE,0x4E1A74E9,0x9C8B6ADE,0x21BD8D05};
CONST UINT_T mont_1[34] = {0x3B481B92,0x72E6B3FE,0x5F3E422B,0x0949B91A,0x698F7931,0x5042C54D,0x4330C82D,0xEC4B907C,0x20083469,0xCCF52C1D,0x9AC063D9,0x2F4065D0,0xF3FEC34B,0x6FF17CD1,0xA8317446,0x657186E5,0x4A74ED73,0xD6F6AB2E,0x9DE9C048,0xC1916796,0x74D68733,0x2FD53D1E,0xAD25B908,0x92711DC7,0x8E753339,0xC2274F57,0x022D2D1A,0xBD024A7A,0x2EB759ED,0x012C87CC,0xF8BB7550,0x80B72F6F,0x00000004,0x00000000};
#define MMUL(a,b,n,np,r,s) big_mont_mul_cios((a),(b),(n),(np),(r),(s))
#define MSQR(a,n,np,r,s)   big_mont_sqr_cios((a),(n),(np),(r),(s))
// -----------------------------------------------

// subtract n if needed
STATIC INLINE int norm(PRIVATE UINT_T* z, CONST UINT_T* n, int s)
{
    if (z[s]) {
	int i;
	UINT_T B;
	SUB(z[0], n[0], &B, &z[0]);
	for (i = 1; i < s; i++) {
	    SUBB(z[i], n[i], B, &B, &z[i]);
	}
    }
    return s;
}

// multiply r = x*y x[n], y[n] r[n]! result is same size as operands
STATIC INLINE void big_mul0(PRIVATE UINT_T* x, PRIVATE UINT_T* y,
			    PRIVATE UINT_T* r, int n)
{
    int i;
    for (i = 0; i < n; i++) {
	UINT_T c = 0;
	int j, ij=i;
	for (j = 0; i+j < n; j++) {
	    MULAB(x[i],y[j],r[ij],c,&c,&r[ij]);
	    ij++;
	}
	r[ij] = c;  // top index is n
    }
}


static void constant_to_private(CONST UINT_T* src, PRIVATE UINT_T* dst, int n)
{
    int i;
    for (i = 0; i < n; i++)
	dst[i] = src[i];
}

static void constant_to_global(CONST UINT_T* src, GLOBAL UINT_T* dst, int n)
{
    int i;
    for (i = 0; i < n; i++)
	dst[i] = src[i];
}


static void global_to_private(GLOBAL UINT_T* src, PRIVATE UINT_T* dst, int n)
{
    int i;
    for (i = 0; i < n; i++)
	dst[i] = src[i];
}

static void private_to_global(PRIVATE UINT_T* src, GLOBAL UINT_T* dst, int n)
{
    int i;
    for (i = 0; i < n; i++)
	dst[i] = src[i];
}

static void zero_to_private(PRIVATE UINT_T* dst, int n)
{
    int i;
    for (i = 0; i < n; i++)
	dst[i] = 0;
}

static void zero_to_global(GLOBAL UINT_T* dst, int n)
{
    int i;
    for (i = 0; i < n; i++)
	dst[i] = 0;
}

__kernel void mul0(GLOBAL UINT_T* a,   // in a[i]
		  GLOBAL UINT_T* b,   // in b[i]
		  GLOBAL UINT_T* r,   // out r[i]
		  const unsigned int n)
{
    UINT_T A[mont_S];
    UINT_T B[mont_S];
    UINT_T R[mont_S];
    const int i = get_global_id(0);

    if (i >= n) return;

    global_to_private(a, A, mont_S);
    global_to_private(b, B, mont_S);
    zero_to_private(R, mont_S);
    big_mul0(A, B, R, mont_S);
    private_to_global(R, r, mont_S);
}

void print_global(GLOBAL UINT_T* x, int xl)
{
    printf("[%d]{", xl);
    if (xl > 0) {
	int i = 0;
	while(i+8 < xl) {
	    printf("  ");
	    printf("%08lx ", (unsigned long)x[i]);
	    printf("%08lx ", (unsigned long)x[i+1]);
	    printf("%08lx ", (unsigned long)x[i+2]);
	    printf("%08lx ", (unsigned long)x[i+3]);
	    printf("%08lx ", (unsigned long)x[i+4]);
	    printf("%08lx ", (unsigned long)x[i+5]);
	    printf("%08lx ", (unsigned long)x[i+6]);
	    printf("%08lx ", (unsigned long)x[i+7]);
	    i += 8;
	    printf("\r\n");
	}
	if (i < xl) {
	    printf("  ");
	    while(i < xl) {
		printf("%08lx ", (unsigned long)x[i]);
		i++;
	    }
	}	
    }
    printf("}\r\n");
}

void print_private(PRIVATE UINT_T* x, int xl)
{
    printf("[%d]{\r\n", xl);
    if (xl > 0) {
	int i = 0;
	while(i+8 < xl) {
	    printf("  ");
	    printf("%08lx ", (unsigned long)x[i]);
	    printf("%08lx ", (unsigned long)x[i+1]);
	    printf("%08lx ", (unsigned long)x[i+2]);
	    printf("%08lx ", (unsigned long)x[i+3]);
	    printf("%08lx ", (unsigned long)x[i+4]);
	    printf("%08lx ", (unsigned long)x[i+5]);
	    printf("%08lx ", (unsigned long)x[i+6]);
	    printf("%08lx ", (unsigned long)x[i+7]);
	    i += 8;
	    printf("\r\n");
	}
	if (i < xl) {
	    printf("  ");
	    while(i < xl) {
		printf("%08lx ", (unsigned long)x[i]);
		i++;
	    }
	}	
    }
    printf("}\r\n");
}

void print_constant(CONST UINT_T* x, int xl)
{
    printf("[%d]{\r\n", xl);
    if (xl > 0) {
	int i = 0;
	while(i+8 < xl) {
	    printf("  ");
	    printf("%08lx ", (unsigned long)x[i]);
	    printf("%08lx ", (unsigned long)x[i+1]);
	    printf("%08lx ", (unsigned long)x[i+2]);
	    printf("%08lx ", (unsigned long)x[i+3]);
	    printf("%08lx ", (unsigned long)x[i+4]);
	    printf("%08lx ", (unsigned long)x[i+5]);
	    printf("%08lx ", (unsigned long)x[i+6]);
	    printf("%08lx ", (unsigned long)x[i+7]);
	    i += 8;
	    printf("\r\n");
	}
	if (i < xl) {
	    printf("  ");
	    while(i < xl) {
		printf("%08lx ", (unsigned long)x[i]);
		i++;
	    }
	}	
    }
    printf("}\r\n");
}

// a = (a^x) mod N
__kernel void montpow(GLOBAL UINT_T* a,   // in/out a[i]
		      GLOBAL UINT_T* x,   // in
		      const unsigned int xbits,  // in (number of bits in e)
		      GLOBAL UINT_T* r,
		      const unsigned int n) // in number of a's and r's

{
    UINT_T P[2][mont_S+2];
    UINT_T A[2][mont_S+2];
    int u, v;
    int pos,j;
    const int i = get_global_id(0);

    if (i >= n) return;

    printf("N="); print_constant(mont_N, mont_S);
    printf("N'="); print_constant(mont_Np, mont_S);
    
    u = 0;
    constant_to_private(mont_1, P[u], mont_S);   // = mont(1) !
    printf("1=P[u]="); print_private(P[u], mont_S);    

    v = 0;
    global_to_private(a+mont_S*i, A[v], mont_S);
    printf("A=A[v]="); print_private(A[v], mont_S);    

    for (pos=1, j=0; pos < xbits; pos += D_SIZE, j++) {
	UINT_T xj = x[j];
	int size = (pos+D_SIZE < xbits) ? D_SIZE : xbits-pos;
	int bit;
	for (bit = 0; bit < size; bit++) {
	    if (xj & 1) {
		zero_to_private(P[!u], mont_S+2);
		MMUL(A[v],P[u],mont_N,mont_Np,P[!u],mont_S);
		norm(P[!u], mont_N, mont_S);
		printf("P[!u]="); print_private(P[!u], mont_S);
		u = !u;
	    }
	    // A' = A^2 (mod R)
	    zero_to_private(A[!v], mont_S+2);
	    MSQR(A[v],mont_N,mont_Np,A[!v],mont_S);
	    norm(A[!v], mont_N, mont_S);
	    printf("A[!v]="); print_private(A[!v], mont_S);
	    v = !v;
	    
	    xj >>= 1;
	}
    }
    zero_to_private(P[!u], mont_S+2);
    MMUL(A[v],P[u],mont_N,mont_Np,P[!u],mont_S);
    norm(P[!u], mont_N, mont_S);
    private_to_global(P[!u], r+mont_S*i, mont_S);
    printf("R=P[!u]="); print_private(P[!u], mont_S);
}
